# APS (Algorithm Problem Solving)

2020.08.03.

```
Index

1. 알고리즘
2. 배열
3. 정렬
```



## 1. 알고리즘이란?

> 페르시아의 수학자 알 콰리즈미(خوارزمی)의 이름에서 유래된 것으로, 어떠한 문제를 해결하기 위한 절자이다.



### 1) 알고리즘을 표현하는 방법:  슈도코드와 순서도

> **의사코드(슈도코드, pseudocode)**는 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하기 위한 언어이다. 특정 프로그래밍 언어의 문법에 따라 쓰인 것이 아니라, 일반적인 언어로 **코드**를 흉내 내어 알고리즘을 써놓은 **코드**를 말한다. (위키백과)

```
# 슈도코드의 예시
def CalcSum(n):
    sum <- 0
    for i in range(1, n+1):
        sum <- sum + i;
    return sum;
```

### 2) 알고리즘의 성능을 측정하는 방법: 시간 복잡도 (Time Complexity, 작업량)

- 실제 걸리는 시간을 측정하는 것으로 실행되는 명령문의 개수 계산

#### 빅-오(O) 표기법 (Big-Oh Notation)

> 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시. 계수(Coefficient)는 생략하여 표시한다.
>
> ex) O(3n+2) = O(3n) = O(n). O(2n^2+10n+100)=O(n^2)

##### (1) P 복잡도(Polynomial -, 다항식)

- O(logn) - 이진탐색
- O(n) - 순차탐색
- O(nlogn) - Quick, Merge, Heap
- O(n^2 - 선택, 버블, 사빕)

##### (2) NP 복잡도(Non-deterministic Polynomial -, 지수) - 근사알고리즘 사용

- O(2^n) - 부분집합, 조합
- O(n!) - 순열



## 2. 배열(Array)이란?

> 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조로 파이썬에서는 list를 뜻한다. 배열을 사용하면 하나의 선언을 통해 둘 이상의 변수를 선언할 수 있다.

### 1차원 배열

선언

별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성

```python
Arr = list()
```

접근

```python
Arr[0] = 10	# 배열 Arr의 0번째 원소에 10을 저장하라
Arr[idx] = 20	# 배열 Arr의 idx번째 원소에 20을 저장하라
```



## 3. 정렬

> 2개 이상의 자료를 특정 기준에 의해 오름차순(ascending) 혹은 내림차순(descending)으로 재배열하는 것

- 종류: 버블소트, 카운팅소트, 선택소트, 퀵소트, 삽입소트, 병합소트

### 1) 버블 정렬(Bubble Sort) - O(n^2)

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식 (* 거품처럼 가벼운 것이 위로 올라가기 때문에 붙은 이름이라고 한다.)

```python
def bubble_sort (a):	# 정렬할 List
    for i in range(len(a)-1, 0, -1):	# 범위의 끝 위치, 비교하는 횟수는 (a의 개수-1)회
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

### 2) 카운팅 정렬(Counting Sort) - O(n+k)

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하며 ,선형 시간에 정렬하는 효율적인 알고리즘

- 정수나 정수로 표현할 수 있는 자료에 대해서만 가능! (각 항목 발생 회수를 기록하기 때문)
- 따라서 문자열은 할 수 없으며, 문자는 아스키코드로 변환하여 사용할 수 있다.
- 카운트를 위한 공간 할당을 위해 집합 내 가장 큰 정수를 알아야한다.

```python
def counting_sort(A, B, k)
# A [] -- 입력 배열(1 to k(최대값))
# B [] -- 정렬된 배열
# C [] -- 카운트 배열

# 목표 배열의 공간 할당
C= [0] * k
# 1단계 카운팅: 각 숫자의 개수 세기
for i in range(0, len(B)):
    C[A[i]] += 1
# 2단계 누적: 각 개수를 왼쪽부터 누적시키기
for i in range(1, len(C)):
    C[i] += C[i-1]
# 3단계 소트: 입력 배열의 마지막 숫자부터 위치대로 입력해 정렬하기
for i in range(len(B)-1, -1, -1):
    B[C[A[i]]-1] = A[i]
    C[A[i]] -= -1
```

#### 완전검색

> 모든 경우의 수를 나열해보고 확인하는 기법. 모든 경우의 수를 생성하고 테스트해서 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인한다.
>
> - 기본 단계에서는 주로 for문을 사용한다.
> - 완전검색(재귀) + 가지치기 = BT(Back Tracking)

#### 



### 3) 선택 정렬(Selection Sort) - O(n^2)

### 4) 퀵 정렬(Quick Sort)  - O(nlogn)

### 5) 삽입 정렬(Insertion Sort) - O(n^2)

### 6) 병합 정렬(Merge Sort) - O(nlogn)



완전검색

